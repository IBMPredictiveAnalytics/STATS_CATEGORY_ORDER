#/***********************************************************************
# * Licensed Materials - Property of IBM 
# *
# * IBM SPSS Products: Statistics Common
# *
# * (C) Copyright IBM Corp. 1989, 2020
# *
# * US Government Users Restricted Rights - Use, duplication or disclosure
# * restricted by GSA ADP Schedule Contract with IBM Corp. 
# ************************************************************************/

__author__ = "IBM SPSS, JKP"
__version__ = "1.3.0"

# history
# 07-26-2013  original version
# 08-09-2013  Add support for other
# 24-11-2014  Add support for ordering variable lists by count
# 26-feb-2016 Add support for custom attribute definition


import spss, spssaux
from extension import Template, Syntax, processcmd

helptext="""
Create macros or MRSETS for variable categories or MD sets or a variable list

STATS CATEGORY ORDER ITEMS=itemlist PREFIX=string NAMES=list of names
SPECIALVALUES = list of special values
SPECIALVARS = list of special variables OTHER=YES or NO
/OPTIONS ORDER=A or D  SPECIALSLOC= ABOVE or BELOW
CATEGORYLABELS = VARLABELS or COUNTEDVALUES
MISSING = INCLUDE or EXCLUDE 
/COUNTORDERING VARIABLES=variable list COUNTVALUES=list of values
    MACRONAME="name" MINCOUNT=number MINPERCENT=value ORDER=A or D
/HELP

ITEMS and either PREFIX or NAMES are required unless COUNTORDERING
is used

Example:
STATS CATEGORY ORDER ITEMS = jobcat edyears $cars PREFIX=reorder.

This procedure creates macro definitions or multiple dichotomy sets for use
in Custom Tables in order to control the category order beyond what is built
in to that procedure.

This procedure processes two types of input.  For an ordinary variable
it creates a macro definition that lists the categories in sorted order of
the counts with the ability to move selected values to the top or bottom
of the list.  A typical usage would be to move an "other" category to the
bottom.  The generated macro can be used in the CTABLES CATEGORIES
subcommand to specify the order.

The second type of input is one or more multiple dichotomy sets.  An
MD set consists of a group of variables representing choices or attributes
as yes (the counted value) or no for each attribute.  The procedure
creates a new MD set consisting of the same variable plus optionally
other similar variables with the variables listed in sorted count
order.  By specifying special variables, typically but not
necessarily included in the set definition, those variables can be moved
to the top or bottom of the list.  Tabulating the new sets with custom tables
will list the variables in the order generated by this procedure.

ITEMLIST specifies the variables and MD sets to process.  All variables either
listed or contained in the sets must have the same fundamental type.

PREFIX or NAMES specify the output names.  PREFIX specifies text that will
be prepended to the input names to form the output.  NAMES specifies
a list of explicit names for the output.  Either PREFIX or NAMES is
required, but only one can be used.

SPECIALVALUES lists the values that are special for ordinary variables.  
String values should be enclosed in quotes if they contain a blank.  
Special values or variables will be moved out of the sort order.

SPECIALVARS lists the variables that contain special values, 
e.g., an "other" variable for MD sets.  These variables will be 
moved out of the sort order.  They do not have to be members of
the input sets.

OTHER specifies whether to add labeled values not found in
the data to the result with a count of zero.  This only applies
to ordinary variables.  If missing values are excluded,
labeled missing values are omitted.

ORDER specifies how the values or variables are sorted: in ascending
or descending order of the count.

SPECIALSLOC specifies whether the special values appear above or below
the other values.

CATEGORYLABELS specifies how set values are labelled.  See the
MRSETS command documentation for details.

MISSING specifies whether or not user missing values are included
based on the data or labels.  If a missing value is listed in
special values, however, it is always included.
By default missing values are excluded.

/HELP displays this text and does nothing else.
"""


import spss, spssaux, spssdata, copy

def catvalues(items=None, prefix=None, names=None, specialvars=None,
    specialsorder="after", order="d", missing="exclude",
    categorylabels="varlabels", specialvalues=None, other=False,
    variables=None, countvalues=None, macroname=None,
    mincount=0, minpercent=0, maxcount = None, maxpercent=None, separator=" ",
    customattr=False, attrname="ORDER"):
    """Construct macros, custom attributes and MR set definitions"""

    ##debugging
    # makes debug apply only to the current thread
    #try:
        #import wingdbstub
        #if wingdbstub.debugger != None:
            #import time
            #wingdbstub.debugger.StopDebug()
            #time.sleep(1)
            #wingdbstub.debugger.StartDebug()
        #import thread
        #wingdbstub.debugger.SetDebugThreads({thread.get_ident(): 1}, default_policy=0)
        # for V19 use
        ##    ###SpssClient._heartBeat(False)
    #except:
        #pass
    weightvar = spss.GetWeightVar()
    # tODO: allow both names and macroname to be None if customattr
    if variables is None:
        if sum([prefix is None, names is None]) != 1 and not customattr:
            raise ValueError(_("""Either a  prefix or a set of macro or MR set names or a custom attribute must be specified"""))
        if names is not None:
            names = spssaux._buildvarlist(names)
            if len(names) != len(items):
                raise ValueError(_("""The number of macro or MR set names specified is different from the number of items"""))
        if prefix is not None:
            names = [prefix + "_" + name for name in items]   # MR sets will have a $ in the macro name
    
        resolver = Resolver()
        allvars, vartypes = resolver.resolve(items)  # check existence and get all variables and variable types
        alltypes = list(vartypes.values())
        # variables, direct or in MR sets, must be either all strings or all numeric
        numerics = any([vartypes[item] == 0 for item in allvars])
        strings = any([vartypes[item] != 0 for item in allvars])
        if numerics and strings:
            raise ValueError(_("""Items to process must be either all numeric or all string"""))
        try:
            if numerics and specialvalues is not None:
                specialvalues = [float(item) for item in specialvalues]
        except:
            raise ValueError(_("""A nonnumeric special value was given for numeric variables"""))
        regularvars = [item for item in items if not item.startswith("$")]
        mrsets = [item for item in items if item.startswith("$")]
        resolver.close()
        if regularvars and other:
            valuelabelsdict, missingvaluesdict = getmetadata(regularvars, missing)
        else:
            valuelabelsdict = None
            missingvaluesdict = None
        
        macrosgenerated = []
        if regularvars:
            macrosgenerated, customattrsgenerated = genVarsCategoryList(regularvars, 
                specialvalues=specialvalues, macroname=names, 
                missing=missing, order=order, weightvar=weightvar, specialsorder=specialsorder, 
                valuelabelsdict=valuelabelsdict, missingvaluesdict=missingvaluesdict,
                customattr=customattr, attrname=attrname)
            spss.StartProcedure("STATS CATEGORY ORDER", "STATSCATEGORYMACRO")
            if customattrsgenerated:
                caption = _("Custom attribute name: %s") % attrname
            else:
                caption = ""
            table = spss.BasePivotTable("Generated Macros or Custom Attributes", 
                "STATSCATMACROS", caption=caption)
            if macrosgenerated:
                gen = macrosgenerated
            else:
                gen = customattrsgenerated
            table.SimplePivotTable(rowdim=_("Name"), rowlabels=[names for names, values in gen],
                collabels = [_("Definition")], cells=[values for names, values in gen])
            spss.EndProcedure()  # can't issue MRSETS command in a procedure state
        # specialvars do not have to have been in the original set.
        if mrsets:
            mrsetsgenerated = genSetsCategoryList(mrsets, allvars, vartypes, 
                resolver, specialvalues=specialvars, macroname=names, 
                missing=missing, order=order, weightvar=weightvar,
                categorylabels=categorylabels, specialsorder=specialsorder, other=other)
    
        # mrset generation displayed via MRSET creation command so not repeated here
        for m in macrosgenerated:
            ###spss.SetMacroValue(m[0], m[1])    # This api mishandles Unicode characters so use syntax instead
            spss.Submit("""DEFINE %s() %s""" %(m[0], m[1]))
            
    if variables is not None:
        if items is not None or names is not None:
            raise ValueError(_("""ITEMS and NAMES cannot be used with COUNTORDERING specifications."""))
        if countvalues is None or macroname is None:
            raise ValueError(_("""The values to count and a macroname must be specified when using COUNTORDERING specifications."""))
        genVarMacro(variables, countvalues, order, macroname, mincount,
            minpercent, maxcount, maxpercent, separator, weightvar, missing)


def getmetadata(variables, missing):
    """Return dictionaries of value labels and missing values
    
    variables is a list of variable names to process
    missing specifies the missing value treatment"""
    
    # vldict is a dictionary indexed by variable name with each entry
    # a set of labelled values
    # missingsdict is a dictionary indexed by variable name with each entry
    # a set of missing values.  Range specifictions are silently ignored.
    # if missing == "exclude", missing values are removed from the labels set
    
    vldict = {}
    missingsdict = {}
    with spss.DataStep():
        ds = spss.Dataset()
        for v in variables:
            vldict[v] = set(ds.varlist[v].valueLabels.data.keys())
            mvs = ds.varlist[v].missingValues
            if mvs[0] < 0:
                mvs = [mvs[3]]
            else:
                mvs = mvs[1:]
            missingsdict[v] = set([item for item in mvs if item is not None])
            if missing == "exclude":
                vldict[v] = vldict[v] - missingsdict[v]
    return vldict, missingsdict 

def genVarsCategoryList(varnames, specialvalues, macroname, missing, order, 
        weightvar, specialsorder, valuelabelsdict, missingvaluesdict,
        customattr, attrname):
    """Generate sorted list(s) of values with possible insertion of extra values
    and return list of SPSS macros to be created.
    
    varnames is a sequence of variable names to process.
    specialvalues is a sequence of values that should be inserted before the first zero count or at the end if no zeros or None.
    If a special value already occurs in a varname, it will be moved.
    macroname is a list of macronames of the same length as varnames to generate or None.
    missing is 'include' or 'exclude' to determine whether user missing values are included or excluded.
    order is 'a' or 'd' to specify the sort direction.
    weightvar can be specified as a variable name to be used as a weight in determing the counts to sort by.
    It must not occur in varnames.
    specialsorder is 'before' or 'after' and indicates the location of the specials section
    If other, values that have value labels are appended to the list of values found
    in the data.
    customattr indicates whether a custom attribute with the order should be generated
    attrname is the name of the custom attribute
    

    This function is mainly useful as a helper function for Ctables in building CATEGORIES subcommands.
    It may be useful to combine it with OTHERNM and/or MISSING in the category list.
    """

    if weightvar:
        if weightvar in varnames:
            raise ValueError(_("""The weight variable cannot be included as a variable."""))
        varnamesAndWeight = varnames + [weightvar]
    else:
        varnamesAndWeight = varnames
    curs = spssdata.Spssdata(indexes=varnamesAndWeight, names=False, omitmissing=missing =='exclude')
    nvar = len(varnames)
    
    vvalues=[{} for i in range(nvar)]  # for accumulating counts for all variable values
    for cn, case in enumerate(curs):
        casecpy = copy.copy(case)
        if weightvar:
            w = casecpy[nvar]
            if w is None:
                w = 0.0
        else:
            w = 1.0
        for i in range(nvar):
            if not casecpy[i] is None:   # omit sysmis values and optionally user missing values
                curval = casecpy[i]
                vvalues[i][curval] = vvalues[i].get(curval,0.) + w   # count occurrences, possibly weighted
    curs.CClose()
    
    valuelist = []
    macrosgenerated = []
    customattrlist = []
    for i, vname in enumerate(varnames):
        # if labeled values were supplied but did not occur in the data,
        # add them with a count of zero
        if not valuelabelsdict is None:
            labeledbutnotfound = valuelabelsdict[vname] - set(vvalues[i].keys())
            for val in labeledbutnotfound:
                vvalues[i][val] = 0.
        if not specialvalues is None:  # remove special values from count list
            for v in specialvalues:
                if v in vvalues[i]:
                    del(vvalues[i][v])
        valuelist.append(sorted([(value, key) for (key, value) in vvalues[i].items()], reverse = order == 'd'))
        if not specialvalues is None:
            if specialsorder == "after":
                valuelist[i].extend([(None, v) for v in specialvalues])
            else:
                valuelist[i] = [(None, v) for v in specialvalues] + valuelist[i]

        if isinstance(valuelist[i][0][1], str):
            qchar = '"'
        else:
            qchar = ''
        if macroname is not None:
            if not macroname[i].startswith("!"):
                macroname[i] = "!" + macroname[i]
            macrosgenerated.append([macroname[i],
                " ".join([qchar + strconv(k).rstrip() + qchar  for (value, k) in valuelist[i]])])
        if customattr:
            customattrlist.append([vname, " ".join([qchar + strconv(k).rstrip() + qchar  for (value, k) in valuelist[i]])])
    
    if customattr:
        try:   # cannot start datastep if there are pending transformations
            spss.StartDataStep()
        except:
            spss.Submit("EXECUTE.")
            spss.StartDataStep()
        ds = spss.Dataset()
        
        for spec in customattrlist:
            ds.varlist[spec[0]].attributes[attrname] = spec[1]
        spss.EndDataStep()
            
        
    return macrosgenerated, customattrlist

def strconv(ch):
    """return ch if already a string; otherwise return its str as it will be a number"""
    
    if isinstance(ch, str):
        return ch
    else:
        return str(ch)


def genSetsCategoryList(mrsets, allvars, vartypes, resolver, specialvalues, macroname, 
        missing, order, weightvar, categorylabels, specialsorder, other):
    """Generate sorted list(s) of values with possible insertion of extra values and create SPSS macros.
    
    varnames is a sequence of mr set names to process.
    allvars is the resolved list of variables in the sets
    vartypes is the list of variable types
    resolver is a class that contains the MR set information from the SPSS dictionary.
    specialvalues is a sequence of values that should be inserted before the first zero count or at the end if no zeros or None.
    If a special value already occurs in a varname, it will be moved.
    macroname is a list of macronames of the same length as varnames to generate or None.
    missing is 'include' or 'exclude' to determine whether user missing values are included or excluded.
    order is 'a' or 'd' to specify the sort direction.
    weightvar can be specified as a variable name to be used as a weight in determing the counts to sort by.  It must not occur in varnames.

    This function is mainly useful as a helper function for Ctables in building CATEGORIES subcommands.
    It may be useful to combine it with other and/or MISSING in the category list."""
    
    for name in mrsets:
        if resolver.getSetType(name) != "Dichotomies":
            raise ValueError(_("""The specified set is a multiple category set.  Only multiple dichotomy sets can be used: %s""")
                % name)
    if weightvar in allvars:
        raise ValueError(_("""The weight variable cannot be included in an MR set."""))
    if weightvar:
        varnamesAndWeight = allvars + [weightvar]
    else:
        varnamesAndWeight = allvars
    curs = spssdata.Spssdata(indexes=varnamesAndWeight, names=False, omitmissing=missing == 'exclude')
    nvar = len(allvars)
    
    vvalues=[{} for i in range(nvar)]  # for accumulating counts for all variable values
    for cn, case in enumerate(curs):
        casecpy = copy.copy(case)
        if weightvar:
            w = casecpy[nvar]
            if w is None:
                w = 0.0
        else:
            w = 1.0
        for i in range(nvar):
            if not casecpy[i] is None:   # omit sysmis values and optionally user missing values
                curval = casecpy[i]
                vvalues[i][curval] = vvalues[i].get(curval,0.) + w   # count occurrences, possibly weighted
    curs.CClose()
    
    # produce value list for variables in a set

    if macroname is None:
        raise ValueError("No macro names were specified")
    manager = ManageValues(mrsetinfo=resolver.mrsets, allvars=allvars, allvalues=vvalues,
        specials=specialvalues, order=order, macroname=macroname, 
        categorylabels=categorylabels, specialsorder=specialsorder, other=other)
    for i, s in enumerate(mrsets):
        manager.collapse(s)
        manager.setgen(macroname[i], s)


def genVarMacro(variables, countvalues, order, macroname, mincount,
            minpercent, maxcount, maxpercent, separator, weightvar, missing):
    """Generate a macro listing the variables in order of the weighted counts
    
    variables is the list of candidate variables
    countvalues is a list of the values to be counted
    order is a or d for the variable order in the macro
    macroname is the name of the macro to be generated
    mincount and minpercent specify minimum thresholds for including a variable (<)
    maxcount and maxpercent specific maximum thresholds (>=)
    separator is the variable name separator to use in the macro definition
    weightvar is the name of the weight variable or None
    missing specifies the missing value treatment"""
    
    if weightvar:
        varnamesAndWeight = variables + [weightvar]
    else:
        varnamesAndWeight = variables
    nvar = len(variables)
    if len(separator) == 0:
        separator = " "
    vardict = spssaux.VariableDict(variables)
    types = set(min(v.VariableType, 1) for v in vardict)
    if len(types) > 1:
        raise ValueError(_("""Variable must all be of the same type"""))
    vartypes = types.pop()
    if vartypes == 0:
        try:
            countvalues = [float(v) for v in countvalues]
        except:
            raise ValueError(_("""A non-numeric value to count was specified for a numeric variable"""))
    else:
        countvalues = [v.rstrip() for v in countvalues]
    countvalues = set(countvalues)
    curs = spssdata.Spssdata(indexes=varnamesAndWeight, names=False, 
        convertUserMissing=False, omitmissing=missing == 'exclude')

    counts = {}  # a dictionary of weighted counts with variable names as keys
    # populate counts as all zeros so that all variables will
    # appear in the dictionary for later use
    for v in variables:
        counts[v] = 0    
    w = 1.0
    wsum = 0
    minpercent = minpercent / 100.
    if maxpercent is not None:
        maxpercent = maxpercent / 100.
    # calculate weighted count of counted values for each variable
    # string variables must be trimmed to match counted values list

    for case in curs:
        if weightvar:
            w = case[nvar]
            if w is None:
                w = 0.0
        wsum += w   # accumulate weight
        if vartypes == 1:
            case = [val.rstrip() for val in case[:nvar]] # don't include any weight variable   
        for i in range(nvar):
            if case[i] in countvalues:
                counts[variables[i]] = counts[variables[i]] + w 
    curs.CClose()
    if wsum == 0:
        raise ValueError(_("""No valid cases were found"""))
    
    # apply thresholds
    excluded = {}
    for v, count in list(counts.items()):
        if count < mincount or count/wsum < minpercent or\
           (maxcount is not None and count >= maxcount) or\
           (maxpercent is not None and count/wsum >= maxpercent):
            excluded[v] = count
            del counts[v]
    if not counts:
        raise ValueError(_("""No variables meet the count or percentage threshold"""))
    
    # generate macro definition order variables by count
    if not macroname.startswith("!"):
        macroname = "!" + macroname
    macrovariables = [item[0] for item in sorted(list(counts.items()), key=lambda x: x[1], 
        reverse = order == "d")]
    spss.SetMacroValue(macroname,
        separator.join(macrovariables))
    
    # report result as pivot table listing variables and counts
    spss.StartProcedure("STATS CATEGORY ORDER", "STATSCATEGORYMACRO")
    caption = [_("""Minimum count: < %s""") % mincount, _("""Minimum percentage: < %s""") % (minpercent * 100)]
    if maxcount is not None:
        caption.append(_("""Maximum count: >= %s""") % maxcount)
    if maxpercent is not None:
        caption.append(_("""Maximum percentage: >= %s""") % (maxpercent * 100))
    caption.append(_("""Variables excluded: %s""") % (nvar - len(macrovariables)))
    caption = "\n".join(caption)
    
    #Minimum percent: %s""")
    #if maxcount is not None
    #\nVariables excluded: %s""") %\
            #(mincount, minpercent*100, nvar - len(macrovariables))    
    pt = spss.BasePivotTable(
        title=_("""Macro Definition: %s""") % macroname,
        templateName="COUNTMACRO",
        isSplit= False,
        caption = caption
    )
    if not weightvar:
        pt.SetDefaultFormatSpec(spss.FormatSpec.Count)
    pt.SimplePivotTable(
        rowdim=_("""Variables"""),
        rowlabels= [spss.CellText.VarName(vardict[v].VariableIndex) for v in macrovariables],
        collabels=[_("""Counts""")],
        cells = [counts[v] for v in macrovariables]
    )
    if excluded:
        pt2 = spss.BasePivotTable(
            title=_("""Excluded Variables for Macro Definition: %s""") % macroname,
            templateName="COUNTMACROEX",
            isSplit= False
        )
        if not weightvar:
            pt2.SetDefaultFormatSpec(spss.FormatSpec.Count)        
        rowlabels = [item[0] for item in sorted(list(excluded.items()), key=lambda x: x[1], 
                reverse = order == "d")]        
        pt2.SimplePivotTable(
            rowdim=_("""Excluded Variables"""),
            rowlabels= [spss.CellText.VarName(vardict[v].VariableIndex) for v in rowlabels],
            collabels=[_("""Counts""")],
            cells = [excluded[v] for v in rowlabels]
        )        
    spss.EndProcedure()
        
    
class ManageValues(object):
    """Manage mr set values"""
    
    def __init__(self, mrsetinfo, allvars, allvalues, specials, 
            order, macroname, categorylabels, specialsorder, other):
        """mrsetinfo is the structure returned by the dataset multiResposneSet api
        Set names are always in upper case
        allvars is a list of all the expanded variable names across all the
        specified variable sets.
        allvalues is a list of dictionaries.
        Each list item is a dictionary of numeric or string values and their 
        count for one variable
        specials is the list of special values
        order is the sort order
        specialsorder is 'before' or 'after' 
        other is True to position empty variables in zero count order"""
        
        attributesFromDict(locals())
        
    def collapse(self, mrset):
        """Calculate statistics for one set"""
        
        self.thismrset = {}
        mrsetup = mrset.upper()
        ismd = self.mrsetinfo[mrsetup][1] == "Dichotomies"
        countedvalue = self.mrsetinfo[mrsetup][2]
        isnumeric = self.mrsetinfo[mrsetup][3] == "Numeric"
        if not isnumeric:
            countedvalue = countedvalue.rstrip()  # ignore trailing blanks
        else:
            countedvalue = float(countedvalue)
        vnames = self.mrsetinfo[mrsetup][4]  # the variables included in this set
        
        if ismd:  # multiple dichotomy set
            # produces a dictionary with the variable name as key and value
            # the count of the counted value
            for v in vnames:
                # value counts for this variable
                theitems = clean(self.allvalues[self.allvars.index(v)])
                self.thismrset[v] = theitems.get(countedvalue, 0)
        else:     # multiple category set
            #accumulate counts across variables of each value
            for v in vnames:
                thevalues = list(self.allvalues[self.allvars.index(v)].keys()) # all values in this var
                for key in thevalues:
                    self.thismrset[key] = self.thismrset.get(key, 0) + \
                        self.allvalues[self.allvars.index(v)][key]
                    
    def setgen(self, outputname, inputsetname):
        """construct a new MR set of the appropriate type"""
        
        # remove special values from count list and reinsert at appropriate point
        # construct new set definition
        if self.specials is None:
            self.specials = []
        for v in self.specials:
            if v in self.thismrset:
                del(self.thismrset[v])
        setvalues = sorted([(value, key) for (key, value) in self.thismrset.items()], reverse = self.order == 'd')
        for j in range(len(setvalues)):
            if setvalues[j][0] == 0 and not self.other:
                if self.specialsorder == "after":
                    setvalues = setvalues[:j] + [(None, v) for v in self.specials] + setvalues[j:]
                else:
                    setvalues = [(None, v) for v in self.specials] + setvalues[:j] + setvalues[j:]
                break
        else:
            if self.specialsorder == "after":
                setvalues.extend([(None, v) for v in self.specials])
            else:
                setvalues = [(None, v) for v in self.specials] + setvalues
        # generate set
        cmd = """MRSETS /MDGROUP NAME=%(outputname)s LABEL="%(label)s" 
        CATEGORYLABELS=%(categorylabels)s
VARIABLES = %(variables)s VALUE=%(value)s
/DISPLAY NAME=[%(outputname)s]"""
        if not outputname.startswith("$"):
            outputname = "$" + outputname
        inputsetname = inputsetname.upper()
        label = self.mrsetinfo[inputsetname][0]
        variables = " ".join([item[1] for item in setvalues])
        value = self.mrsetinfo[inputsetname][2]
        if self.mrsetinfo[inputsetname][3] == "String":
            value = spssaux._smartquote(value)
        categorylabels = self.categorylabels
        spss.Submit(cmd % locals())

def clean(items):
    """trim trailing blanks in items
    items is a dictionary of numeric or string value keys and associated values"""
    
    keys = list(items.keys())
    if isinstance(keys[0], str):  # types must be homogeneous
        return dict(list(zip([item.rstrip() for item in keys], list(items.values()))))
    else:
        return items
    
def StartProcedure(procname, omsid):
    """Start a procedure
    
    procname is the name that will appear in the Viewer outline.  It may be translated
    omsid is the OMS procedure identifier and should not be translated.
    
    Statistics versions prior to 19 support only a single term used for both purposes.
    For those versions, the omsid will be use for the procedure name.
    
    While the spss.StartProcedure function accepts the one argument, this function
    requires both."""
    
    try:
        spss.StartProcedure(procname, omsid)
    except TypeError:  #older version
        spss.StartProcedure(omsid)
        
def attributesFromDict(d):
    """build self attributes from a dictionary d."""
    
    self = d.pop('self')
    for name, value in d.items():
        setattr(self, name, value)

class Resolver(object):
    "Manage mixed variables and mr sets"
    
    def __init__(self):
        ##self.vardict = spssaux.VariableDict()
        spss.StartDataStep()
        self.ds = spss.Dataset()
        self.varlist = self.ds.varlist
        self.mrsets = {}
        # the api always returns the set name in upper case
        for name, theset in self.ds.multiResponseSet.data.items():
            self.mrsets[name.upper()] = theset
            
    def close(self):
        try:
            spss.EndDataStep()
        except:
            pass

    def resolve(self, itemlist):
        """Return list of variables and dictionary of types in itemlist.  Fail if a name does not exist.
        
        itemlist is a list of variable and mr set names"""
        
        items = []
        itemtypes = {}
        for item in itemlist:
            if not item.startswith("$"):
                if not item in [itemz.name for itemz in self.varlist]:
                    raise ValueError(_("""Variable not found: %s""") % item)
                else:
                    items.append(item)
                    itemtypes[item] = self.varlist[item].type
            else:
                #When getting a multiple response set, the result is a tuple of 5 elements. The first element is the label,
                #if any, for the set. The second element specifies the variable coding--'Categories' or 'Dichotomies'. The
                #third element specifies the counted value and only applies to multiple dichotomy sets. The fourth
                #element specifies the data type--'Numeric' or 'String'. The fifth element is a list of the elementary
                #variables that define the set.
                if not item.upper() in self.mrsets:
                    raise ValueError(_("""MR set not found: %s""") % item)
                for v in self.mrsets[item.upper()][4]:
                    items.append(v)
                    itemtypes[v] = self.varlist[v].type
        return [items, itemtypes]
    
    def getSetType(self, name):
        """Return the mr set type
        
        name is the set name to check
        return value is "Dichotomies" or "Categories" """
        
        return self.mrsets[name.upper()][1]
                
def Run(args):
    """Execute the STATS CATEGORY ORDER command"""

    args = args[list(args.keys())[0]]
    ###print args   #debug
    

    oobj = Syntax([
        Template("ITEMS", subc="",  ktype="varname", var="items", islist=True),
        Template("PREFIX", subc="",  ktype="literal", var="prefix"),
        Template("NAMES", subc="", ktype="literal", var="names", islist=True),
        Template("SPECIALVARS", subc="", ktype="existingvarlist", var="specialvars", islist=True),
        Template("SPECIALVALUES", subc="", ktype="literal", var="specialvalues", islist=True),
        Template("OTHER", subc="", ktype="bool", var="other"),
        Template("CUSTOMATTR", subc="", ktype="bool", var="customattr"),
        Template("ATTRNAME", subc="", ktype="varname", var="attrname"),
        
        Template("ORDER", subc="OPTIONS", ktype="str", var="order",
            vallist=["a", "d"]),
        Template("SPECIALSLOC", subc="OPTIONS", ktype="str", var="specialsorder",
            vallist=["after", "before"]),        
        Template("MISSING", subc="OPTIONS", ktype="str", var="missing",
            vallist=["include", "exclude"]),
        Template("CATEGORYLABELS", subc="OPTIONS", ktype="str", var="categorylabels",
            vallist=["varlabels", "countedvalues"]),
        
        Template("VARIABLES", subc="COUNTORDERING", ktype="existingvarlist",
            var="variables", islist=True),
        Template("COUNTVALUES", subc="COUNTORDERING", ktype="literal",
            var="countvalues", islist=True),
        Template("MACRONAME", subc="COUNTORDERING", ktype="literal",
            var="macroname"),
        Template("MINCOUNT", subc="COUNTORDERING", ktype="float",
            var="mincount", vallist=[0]),
        Template("MINPERCENT", subc="COUNTORDERING", ktype="float",
            var="minpercent", vallist=[0, 100]),
        Template("MAXCOUNT", subc="COUNTORDERING", ktype="float",
            var="maxcount", vallist=[0]),
        Template("MAXPERCENT", subc="COUNTORDERING", ktype="float",
            var="maxpercent", vallist=[0, 100]),        
        Template("SEPARATOR", subc="COUNTORDERING", ktype="literal",
            var="separator"),

        Template("HELP", subc="", ktype="bool")])
    
        # ensure localization function is defined
    global _
    try:
        _("---")
    except:
        def _(msg):
            return msg

        # A HELP subcommand overrides all else
    if "HELP" in args:
        #print helptext
        helper()
    else:
            processcmd(oobj, args, catvalues)

def helper():
    """open html help in default browser window
    
    The location is computed from the current module name"""
    
    import webbrowser, os.path
    
    path = os.path.splitext(__file__)[0]
    helpspec = "file://" + path + os.path.sep + \
         "markdown.html"
    
    # webbrowser.open seems not to work well
    browser = webbrowser.get()
    if not browser.open_new(helpspec):
        print(("Help file not found:" + helpspec))
try:    #override
    from extension import helper
except:
    pass        